pacman::p_load(data.table, ggplot2)
# ---- q5: graph the probability of investment as a function of mileage
new_data_plot <- data.table(mileage = seq(0, 40, 0.1))

# for each mileage, we need to calculate the probability of investment
# calculating the predicted probability requires continuation value for v1 and v0
# v1 and v0 are calculated by simulation

v_1_matrix_plot <- simulate(new_data_plot$mileage, 1, K = 10, T = 100, beta = 0.99)
v_0_matrix_plot <- simulate(new_data_plot$mileage, 0, K = 10, T = 100, beta = 0.99)
v_matrix_plot <- v_1_matrix_plot - v_0_matrix_plot
new_data_plot <- cbind(new_data_plot, v_matrix_plot)
new_data_plot[, prob := predict(logit, new_data_plot, type = "response")]
saveRDS(new_data_plot, "Data/Out/data_q5.RDS")

graph2 <- ggplot(new_data_plot, aes(x = mileage)) +
    geom_point(aes(y = prob), color = "#FF0000") +
    labs(title = "Conditional Choice Probability", x = "Mileage", y = "Probability")

ggsave("Figures/ccp_dynamic.png", graph2)
ggsave("Figures/ccp_dynamic.pdf", graph2)

rm(list = ls())
# ----q6 extra: compare the estimation results and speed under different reduced form CCP models and different K and T
load("Data/Out/q3.RData")
K_list <- c(10, 20)
T_list <- c(100, 200)
model_list <- list(ccp_probit1, ccp_probit2, ccp_probit3, ccp_probitlog)
model_name_list <- list("probit1", "probit2", "probit3", "probitlog")
grid <- expand.grid(model = model_name_list, K = K_list, T = T_list)
results_matrix <- matrix(0, nrow = length(K_list) * length(T_list) * length(model_list), ncol = 3)
row <- 1
for (model in model_list) {
    for (K in K_list) {
        for (T in T_list) {
            start <- Sys.time()
            v_1 <- simulate(dt$mileage, 1, K, T, beta = 0.99, model)
            v_0 <- simulate(dt$mileage, 0, K, T, beta = 0.99, model)
            v_diff <- v_1 - v_0
            dt2 <- cbind(dt, v_diff)
            logit <- glm(choice ~ x_i1 + x_i2 - 1, offset = x_i3, data = dt2, family = binomial(link = "logit"))
            end <- Sys.time()
            results_matrix[row, ] <- c(end - start, logit$coefficients[[1]], logit$coefficients[[2]])
            row <- row + 1
        }
    }
}
comp_results <- as.data.table(cbind(grid, results_matrix))
rownames(comp_results) <- c("model", "K", "T", "time", "RC", "$\\mu$")
saveRDS(comp_results, "Data/Out/q6.RDS")
print(xtable::xtable(comp_results), floating = FALSE, type = "latex", file = "Tables/q6_comparison.tex", sanitize.rownames.function = identity)


# ---- parrallelized version (generated by ChatGPT4o)
pacman::p_load(doParallel, foreach)

# Load Data
load("Data/Out/q3.RData")

# Define Parameter Lists
K_list <- c(10, 20)
T_list <- c(100, 200)
model_list <- list(ccp_probit1, ccp_probit2, ccp_probit3, ccp_probitlog)
model_name_list <- c("probit1", "probit2", "probit3", "probitlog")

# Create Grid of Parameters
grid <- expand.grid(model = model_name_list, K = K_list, T = T_list)

# Set Up Parallel Backend
num_cores <- detectCores() - 1 # Use available cores minus 1 to prevent overloading
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Run Simulations in Parallel
comp_results <- foreach(i = 1:nrow(grid), .combine = rbind, .packages = c("data.table", "stats")) %dopar% {
    model <- model_list[[which(model_name_list == grid$model[i])]]
    K <- grid$K[i]
    T <- grid$T[i]

    start <- Sys.time()
    v_1 <- simulate(dt$mileage, 1, K, T, beta = 0.99, model)
    v_0 <- simulate(dt$mileage, 0, K, T, beta = 0.99, model)
    v_diff <- v_1 - v_0
    dt2 <- cbind(dt, v_diff)

    logit <- glm(choice ~ x_i1 + x_i2 - 1, offset = x_i3, data = dt2, family = binomial(link = "logit"))
    end <- Sys.time()

    c(grid$model[i], K, T, as.numeric(end - start), logit$coefficients[[1]], logit$coefficients[[2]])
}

# Convert to Data Table & Save
dt_comp_results <- as.data.table(cbind(grid, comp_results[, 4:6]))
setnames(dt_comp_results, c("model", "K", "T", "time", "RC", "\\mu"))
saveRDS(dt_comp_results, "Data/Out/q6.RDS")
print(xtable::xtable(dt_comp_results), floating = FALSE, type = "latex", file = "Tables/q6_comparison.tex", sanitize.rownames.function = identity)
# Stop Cluster
stopCluster(cl)
